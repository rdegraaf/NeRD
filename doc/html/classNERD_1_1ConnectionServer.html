<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Network Rerouter Daemon (nerd): NERD::ConnectionServer Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Network Rerouter Daemon (nerd)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceNERD.html">NERD</a>      </li>
      <li class="navelem"><a class="el" href="classNERD_1_1ConnectionServer.html">ConnectionServer</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">NERD::ConnectionServer Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="NERD::ConnectionServer" -->
<p>The main class for the Network Rerouter Daemon (nerd).  
 <a href="classNERD_1_1ConnectionServer.html#details">More...</a></p>

<p><a href="classNERD_1_1ConnectionServer-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNERD_1_1ConnectionServer_1_1AddressPair.html">AddressPair</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The source and destination addresses of IP packets travelling in one direction in a connection.  <a href="structNERD_1_1ConnectionServer_1_1AddressPair.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer_1_1AddressPairHash.html">AddressPairHash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that computes a hash of an <a class="el" href="structNERD_1_1ConnectionServer_1_1AddressPair.html" title="The source and destination addresses of IP packets travelling in one direction in a connection...">AddressPair</a>, suitable for use with __gnu_cxx::hash_map.  <a href="classNERD_1_1ConnectionServer_1_1AddressPairHash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer_1_1Connection.html">Connection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of a connection managed by a server program.  <a href="classNERD_1_1ConnectionServer_1_1Connection.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNERD_1_1ConnectionServer_1_1PendingConnection.html">PendingConnection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Information pertaining to a server that is starting up to handle a connection.  <a href="structNERD_1_1ConnectionServer_1_1PendingConnection.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer_1_1ServerExitHandler.html">ServerExitHandler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to handle SIGCHLD signals received through <a class="el" href="classLibWheel_1_1SignalQueue.html" title="A system for synchronously handling asynchronous signals in a uni-threaded process.">LibWheel::SignalQueue</a>.  <a href="classNERD_1_1ConnectionServer_1_1ServerExitHandler.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNERD_1_1ConnectionServer_1_1ServerRecord.html">ServerRecord</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a server program to be started.  <a href="structNERD_1_1ConnectionServer_1_1ServerRecord.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer_1_1ServerWritebackHandler.html">ServerWritebackHandler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to handle SIGIO signals received through <a class="el" href="classLibWheel_1_1SignalQueue.html" title="A system for synchronously handling asynchronous signals in a uni-threaded process.">LibWheel::SignalQueue</a>.  <a href="classNERD_1_1ConnectionServer_1_1ServerWritebackHandler.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer_1_1UnknownConnectionException.html">UnknownConnectionException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown by <a class="el" href="classNERD_1_1ConnectionServer.html#afd85b7ad69696355650a0177d01f0a06" title="Looks up a redirection rule for a TCP packet.">getRedirectRule()</a> when a packet does not match any existing connection record.  <a href="classNERD_1_1ConnectionServer_1_1UnknownConnectionException.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer_1_1UnknownServerException.html">UnknownServerException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown by <a class="el" href="classNERD_1_1ConnectionServer.html#a9d75b0d048d374095c4d7c96e4add7f8" title="Attempts to find a server program to run in response to a connection request.">findServer()</a> when no server program can be found to handle a new connection.  <a href="classNERD_1_1ConnectionServer_1_1UnknownServerException.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classLibWheel_1_1WaitList.html">LibWheel::WaitList</a><br class="typebreak"/>
&lt; <a class="el" href="structNERD_1_1ConnectionServer_1_1PendingConnection.html">PendingConnection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#ac838d247f33cef856ae722343a8cb7ff">PendingConnectionList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of pending connections.  <a href="#ac838d247f33cef856ae722343a8cb7ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classLibWheel_1_1WaitList.html">LibWheel::WaitList</a><br class="typebreak"/>
&lt; std::pair&lt; <a class="el" href="classNERD_1_1ConnectionServer.html#a1f7b6abdda0f0a7a027a5f2e24727cee">RedirectionTable</a> <br class="typebreak"/>
*, RedirectionTable::iterator &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a63d211040487b4566f2f696026723932">TimeoutList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of redirection rules that are scheduled to be deleted at their expiry of timers.  <a href="#a63d211040487b4566f2f696026723932"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#acc6df09182bd47a744638d2784a7f3df">ConnectionServer</a> (const std::string &amp;root, bool verb, bool restrict)  throw (IPQ::IpqException, LibWheel::IOException, LibWheel::SocketException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classNERD_1_1ConnectionServer.html" title="The main class for the Network Rerouter Daemon (nerd).">ConnectionServer</a>.  <a href="#acc6df09182bd47a744638d2784a7f3df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#abd4458dd96ff0b366de34ecf24855ec4">~ConnectionServer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for <a class="el" href="classNERD_1_1ConnectionServer.html" title="The main class for the Network Rerouter Daemon (nerd).">ConnectionServer</a>.  <a href="#abd4458dd96ff0b366de34ecf24855ec4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#af506b23a0c81f40f8f449bb388005424">operator()</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main loop for <a class="el" href="classNERD_1_1ConnectionServer.html" title="The main class for the Network Rerouter Daemon (nerd).">ConnectionServer</a>.  <a href="#af506b23a0c81f40f8f449bb388005424"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a52574c2792a324c56435234da19cc183">printStats</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print current server status to <a class="el" href="namespaceLibWheel.html#af4ca70f4f65b2948701218436516a679" title="Global logmsg object.">LibWheel::logmsg</a>.  <a href="#a52574c2792a324c56435234da19cc183"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef __gnu_cxx::hash_map<br class="typebreak"/>
&lt; <a class="el" href="structNERD_1_1ConnectionServer_1_1AddressPair.html">AddressPair</a>, <a class="el" href="structNERD_1_1ConnectionServer_1_1AddressPair.html">AddressPair</a>, <br class="typebreak"/>
<a class="el" href="classNERD_1_1ConnectionServer_1_1AddressPairHash.html">AddressPairHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a1f7b6abdda0f0a7a027a5f2e24727cee">RedirectionTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A look-up table mapping the addresses of packets to redirection rules.  <a href="#a1f7b6abdda0f0a7a027a5f2e24727cee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef __gnu_cxx::hash_map<br class="typebreak"/>
&lt; pid_t, <a class="el" href="classNERD_1_1ConnectionServer_1_1Connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a0cd661f2a6755c501ac198229675ad4d">ServerTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A look-up table mapping server process IDs to the connections that they manage.  <a href="#a0cd661f2a6755c501ac198229675ad4d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a5b183a39539b07fe4a92ef3ad88d7c92">handlePacket</a> (<a class="el" href="classIPQ_1_1IpqPacket.html">IPQ::IpqPacket</a> *pkt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a packet.  <a href="#a5b183a39539b07fe4a92ef3ad88d7c92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structNERD_1_1ConnectionServer_1_1AddressPair.html">AddressPair</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#afd85b7ad69696355650a0177d01f0a06">getRedirectRule</a> (const <a class="el" href="classIPQ_1_1IpqTcpPacket.html">IPQ::IpqTcpPacket</a> *pkt) const   throw (UnknownConnectionException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a redirection rule for a TCP packet.  <a href="#afd85b7ad69696355650a0177d01f0a06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structNERD_1_1ConnectionServer_1_1AddressPair.html">AddressPair</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#aca2ea51c7622b3ecb11cbaa976b9a137">getRedirectRule</a> (const <a class="el" href="classIPQ_1_1IpqUdpPacket.html">IPQ::IpqUdpPacket</a> *pkt) const   throw (UnknownConnectionException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a redirection rule for a UDP packet.  <a href="#aca2ea51c7622b3ecb11cbaa976b9a137"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#af4ba681fed213914c83661a1dfd8df6d">createConnection</a> (<a class="el" href="classIPQ_1_1IpqTcpPacket.html">IPQ::IpqTcpPacket</a> *pkt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a TCP connection.  <a href="#af4ba681fed213914c83661a1dfd8df6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#ae713c47afe1f248809de764dfda4f1b2">createConnection</a> (<a class="el" href="classIPQ_1_1IpqUdpPacket.html">IPQ::IpqUdpPacket</a> *pkt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a UDP connection.  <a href="#ae713c47afe1f248809de764dfda4f1b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a9d75b0d048d374095c4d7c96e4add7f8">findServer</a> (<a class="el" href="structNERD_1_1ConnectionServer_1_1ServerRecord.html">ServerRecord</a> &amp;rec, in_addr_t addr) const   throw (UnknownServerException)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find a server program to run in response to a connection request.  <a href="#a9d75b0d048d374095c4d7c96e4add7f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a31818d0fbe0366a7b902095445405406">isExecutable</a> (const std::string &amp;file) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a file is executable.  <a href="#a31818d0fbe0366a7b902095445405406"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIPQ_1_1IpqSocket.html">IPQ::IpqSocket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#ad9575a11fd2db34b92ab1627c2d1d5b0">sock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to libipq.  <a href="#ad9575a11fd2db34b92ab1627c2d1d5b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a5e476e6dd3a15d073b4a3f75569dc240">serverRoot</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The directory in which to search for server programs.  <a href="#a5e476e6dd3a15d073b4a3f75569dc240"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a36f12900d6c2461984a1e093bfc42403">verbose</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>true</b> to log extra messages; <b>false</b> otherwise  <a href="#a36f12900d6c2461984a1e093bfc42403"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNERD_1_1ConnectionServer.html#ac838d247f33cef856ae722343a8cb7ff">PendingConnectionList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#ad051d0ac714b53904e86c368cd90275c">pendingConnections</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of servers (and associated initial packets) which have been started but have not yet responded with packet numbers.  <a href="#ad051d0ac714b53904e86c368cd90275c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNERD_1_1ConnectionServer.html#a1f7b6abdda0f0a7a027a5f2e24727cee">RedirectionTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a4186be4b373165c72ab81a73165cb075">redirections</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash table of rules governing packet redirections for open conncetions.  <a href="#a4186be4b373165c72ab81a73165cb075"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNERD_1_1ConnectionServer.html#a63d211040487b4566f2f696026723932">TimeoutList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#adc22ef94ff5d014433eef07e054e1d69">timeoutList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of redirection rules to be deleted when timeouts expire.  <a href="#adc22ef94ff5d014433eef07e054e1d69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNERD_1_1ConnectionServer.html#a0cd661f2a6755c501ac198229675ad4d">ServerTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a990a4882c5123f35208d36cabb5fef67">servers</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash table of server process IDs and the connections that they handle.  <a href="#a990a4882c5123f35208d36cabb5fef67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNERD_1_1ConnectionServer_1_1ServerExitHandler.html">ServerExitHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a87fc9625f6d518ffe294e4f759d3cae0">exitHandler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The functor that handles SIGCHLD signals when servers exit.  <a href="#a87fc9625f6d518ffe294e4f759d3cae0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNERD_1_1ConnectionServer_1_1ServerWritebackHandler.html">ServerWritebackHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a8aa938754f8f34144d205d4dd208d91a">writebackHandler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The functor that handles SIGIO signals when servers write back their port numbers.  <a href="#a8aa938754f8f34144d205d4dd208d91a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#ae54611cb80881c2a73d69e145df4bbd7">restrict_servers</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>true</b> to limit the privileges of server programs; <b>false</b> otherwise.  <a href="#ae54611cb80881c2a73d69e145df4bbd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNERD_1_1ConnectionServer.html#a3168fab5ca817d2cd2cb7ca15228440d">magic_sock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A socket bound to 127.0.0.1:MAGIC_PORT/TCP.  <a href="#a3168fab5ca817d2cd2cb7ca15228440d"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The main class for the Network Rerouter Daemon (nerd). </p>
<p>Responsible for receiving packets from kernelspace via libipq, launching servers to handle them, creating and tracking connections, and forwarding packets.</p>
<p>Packets are received from kernelspace in operator(), from which they are passed to <a class="el" href="classNERD_1_1ConnectionServer.html#a5b183a39539b07fe4a92ef3ad88d7c92" title="Handle a packet.">handlePacket()</a> for handling. If a packet is part of an existing connection, it are redirected to its destination server from there. Otherwise, <a class="el" href="classNERD_1_1ConnectionServer.html#af4ba681fed213914c83661a1dfd8df6d" title="Creates a TCP connection.">createConnection()</a> is called to create a connection. If an appropriate server can be found (see <a class="el" href="classNERD_1_1ConnectionServer.html#a9d75b0d048d374095c4d7c96e4add7f8" title="Attempts to find a server program to run in response to a connection request.">findServer()</a>), then the server is launched and the packet queued pending a message from the server indicating the port that it is using. Otherwise, the packet is accepted without modification.</p>
<p>Servers are responsible for writing their listen port numbers to stdout (file descriptor 1) as two-byte messages in network byte order. If this does not occur within 10 seconds of a server starting, then it is assumed to be malfunctioning, is sent a SIGINT, and is dropped. The initial packet associated with such a server is accepted unmodified.</p>
<p>Notification that a server has written its port number back comes through SIGIO signals, which are handled synchronously by a functor of type <a class="el" href="classNERD_1_1ConnectionServer_1_1ServerWritebackHandler.html" title="Functor to handle SIGIO signals received through LibWheel::SignalQueue.">ConnectionServer::ServerWritebackHandler</a> in operator() via <a class="el" href="classLibWheel_1_1SignalQueue.html" title="A system for synchronously handling asynchronous signals in a uni-threaded process.">LibWheel::SignalQueue</a>. This functor creates redirection rules for packets travelling both too and from the server.</p>
<p>Connections are closed when SIGCHLD is received from their server processes, indicating that they have exited. A function of type <a class="el" href="classNERD_1_1ConnectionServer_1_1ServerExitHandler.html" title="Functor to handle SIGCHLD signals received through LibWheel::SignalQueue.">ServerExitHandler</a> is responsible for handling SIGCHID, again through <a class="el" href="classLibWheel_1_1SignalQueue.html" title="A system for synchronously handling asynchronous signals in a uni-threaded process.">LibWheel::SignalQueue</a>. <a class="el" href="classNERD_1_1ConnectionServer_1_1Connection.html" title="A description of a connection managed by a server program.">Connection</a> redirection rules persist for <code>NERD_CONNECTION_TIMEOUT</code> seconds after their servers exit.</p>
<p>SIGALRM is used internally to implement timeouts. As with all other signals used in this program, it is handled synchronously through <a class="el" href="classLibWheel_1_1SignalQueue.html" title="A system for synchronously handling asynchronous signals in a uni-threaded process.">LibWheel::SignalQueue</a>.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>As described above, servers that have not responded within 10 seconds are assumed to be malfunctioning and are dropped. However, if the server is in fact still running, it will exit when it receives the SIGINT or at some later time. This will result in a warning message indicating that SIGCHLD was received from a process for which no record exists. This could probably be fixed, but an extra log message is not currently considered to be a problem worthy of the effort required to fix it. </dd></dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ac838d247f33cef856ae722343a8cb7ff"></a><!-- doxytag: member="NERD::ConnectionServer::PendingConnectionList" ref="ac838d247f33cef856ae722343a8cb7ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classLibWheel_1_1WaitList.html">LibWheel::WaitList</a>&lt;<a class="el" href="structNERD_1_1ConnectionServer_1_1PendingConnection.html">PendingConnection</a>&gt; <a class="el" href="classNERD_1_1ConnectionServer.html#ac838d247f33cef856ae722343a8cb7ff">NERD::ConnectionServer::PendingConnectionList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of pending connections. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This type is public because specializations of <a class="el" href="classLibWheel_1_1WaitList.html" title="A list from which items will be removed after a timeout.">LibWheel::WaitList</a> are outsideof this class. </dd></dl>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00207">207</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f7b6abdda0f0a7a027a5f2e24727cee"></a><!-- doxytag: member="NERD::ConnectionServer::RedirectionTable" ref="a1f7b6abdda0f0a7a027a5f2e24727cee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __gnu_cxx::hash_map&lt;<a class="el" href="structNERD_1_1ConnectionServer_1_1AddressPair.html">AddressPair</a>, <a class="el" href="structNERD_1_1ConnectionServer_1_1AddressPair.html">AddressPair</a>, <a class="el" href="classNERD_1_1ConnectionServer_1_1AddressPairHash.html">AddressPairHash</a>&gt; <a class="el" href="classNERD_1_1ConnectionServer.html#a1f7b6abdda0f0a7a027a5f2e24727cee">NERD::ConnectionServer::RedirectionTable</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A look-up table mapping the addresses of packets to redirection rules. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00163">163</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0cd661f2a6755c501ac198229675ad4d"></a><!-- doxytag: member="NERD::ConnectionServer::ServerTable" ref="a0cd661f2a6755c501ac198229675ad4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __gnu_cxx::hash_map&lt;pid_t, <a class="el" href="classNERD_1_1ConnectionServer_1_1Connection.html">Connection</a>&gt; <a class="el" href="classNERD_1_1ConnectionServer.html#a0cd661f2a6755c501ac198229675ad4d">NERD::ConnectionServer::ServerTable</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A look-up table mapping server process IDs to the connections that they manage. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00186">186</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63d211040487b4566f2f696026723932"></a><!-- doxytag: member="NERD::ConnectionServer::TimeoutList" ref="a63d211040487b4566f2f696026723932" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classLibWheel_1_1WaitList.html">LibWheel::WaitList</a>&lt;std::pair&lt;<a class="el" href="classNERD_1_1ConnectionServer.html#a1f7b6abdda0f0a7a027a5f2e24727cee">RedirectionTable</a>*, RedirectionTable::iterator&gt; &gt; <a class="el" href="classNERD_1_1ConnectionServer.html#a63d211040487b4566f2f696026723932">NERD::ConnectionServer::TimeoutList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of redirection rules that are scheduled to be deleted at their expiry of timers. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This type is public because specializations of <a class="el" href="classLibWheel_1_1WaitList.html" title="A list from which items will be removed after a timeout.">LibWheel::WaitList</a> are outsideof this class. </dd></dl>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00215">215</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acc6df09182bd47a744638d2784a7f3df"></a><!-- doxytag: member="NERD::ConnectionServer::ConnectionServer" ref="acc6df09182bd47a744638d2784a7f3df" args="(const std::string &amp;root, bool verb, bool restrict)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NERD::ConnectionServer::ConnectionServer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>restrict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="classIPQ_1_1IpqException.html">IPQ::IpqException</a>, <a class="el" href="classLibWheel_1_1IOException.html">LibWheel::IOException</a>, <a class="el" href="classLibWheel_1_1SocketException.html">LibWheel::SocketException</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for <a class="el" href="classNERD_1_1ConnectionServer.html" title="The main class for the Network Rerouter Daemon (nerd).">ConnectionServer</a>. </p>
<p>Connect to libipq, register handlers for SIGCHLD and SIGIO with <a class="el" href="classLibWheel_1_1SignalQueue.html" title="A system for synchronously handling asynchronous signals in a uni-threaded process.">LibWheel::SignalQueue</a>, and perform other initialization tasks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The directory in which to search for server programs. </td></tr>
    <tr><td class="paramname">verb</td><td><b>true</b> to enable verbose logging; <b>false</b> otherwise. </td></tr>
    <tr><td class="paramname">restrict</td><td><b>true</b> to restrict server privileges; false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classIPQ_1_1IpqException.html" title="Base class for exceptions thrown by IPQ methods.">IPQ::IpqException</a></td><td>If there is an error initializing libipq. </td></tr>
    <tr><td class="paramname"><a class="el" href="classLibWheel_1_1IOException.html" title="Exception thrown when an I/O error occurs.">LibWheel::IOException</a></td><td>If <em>root</em> is not a readable directory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classLibWheel_1_1SocketException.html" title="Exception thrown when a socket error occurs.">LibWheel::SocketException</a></td><td>If MAGIC_PORT cannot be bound to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00413">413</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>References <a class="el" href="IPQ_8hpp_source.html#l00086">IPQ::IpqSocket::PACKET</a>, <a class="el" href="libwheel_8h_source.html#l00044">QUOTE</a>, <a class="el" href="nerd_8cpp_source.html#l00049">MAGIC_PORT</a>, <a class="el" href="nerd_8cpp_source.html#l00048">LOCALHOST_IP</a>, <a class="el" href="Signals_8cpp_source.html#l00193">LibWheel::SignalQueue::setHandler()</a>, <a class="el" href="Signals_8hpp_source.html#l00131">LibWheel::SignalQueue::HANDLE</a>, and <a class="el" href="Signals_8cpp_source.html#l00234">LibWheel::SignalQueue::addHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="abd4458dd96ff0b366de34ecf24855ec4"></a><!-- doxytag: member="NERD::ConnectionServer::~ConnectionServer" ref="abd4458dd96ff0b366de34ecf24855ec4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NERD::ConnectionServer::~ConnectionServer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor for <a class="el" href="classNERD_1_1ConnectionServer.html" title="The main class for the Network Rerouter Daemon (nerd).">ConnectionServer</a>. </p>
<p>Unregisters signal handlers for SIGIO and SIGCHLD from <a class="el" href="classLibWheel_1_1SignalQueue.html" title="A system for synchronously handling asynchronous signals in a uni-threaded process.">LibWheel::SignalQueue</a> and shuts down libipq. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00463">463</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>References <a class="el" href="Signals_8hpp_source.html#l00156">LibWheel::SignalQueue::deleteHandler()</a>, <a class="el" href="nerd_8cpp_source.html#l00287">writebackHandler</a>, <a class="el" href="nerd_8cpp_source.html#l00286">exitHandler</a>, <a class="el" href="nerd_8cpp_source.html#l00289">magic_sock</a>, <a class="el" href="nerd_8cpp_source.html#l00279">sock</a>, <a class="el" href="IPQ_8cpp_source.html#l00243">IPQ::IpqSocket::close()</a>, <a class="el" href="Logmsg_8hpp_source.html#l00047">LibWheel::logmsg</a>, and <a class="el" href="logmsg_8h_source.html#l00072">logmsg_err</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af4ba681fed213914c83661a1dfd8df6d"></a><!-- doxytag: member="NERD::ConnectionServer::createConnection" ref="af4ba681fed213914c83661a1dfd8df6d" args="(IPQ::IpqTcpPacket *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NERD::ConnectionServer::createConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIPQ_1_1IpqTcpPacket.html">IPQ::IpqTcpPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a TCP connection. </p>
<p>If a program can be found to handle the connection (see <a class="el" href="classNERD_1_1ConnectionServer.html#a9d75b0d048d374095c4d7c96e4add7f8" title="Attempts to find a server program to run in response to a connection request.">ConnectionServer::findServer()</a>), then this program fork()s and attempts to execute it in the child process. If no server can be found, if it cannot be launched, or some other error occurs, the packet is immediately accepted and a message may be logged to <a class="el" href="namespaceLibWheel.html#af4ca70f4f65b2948701218436516a679" title="Global logmsg object.">LibWheel::logmsg</a>.</p>
<p>The child process is executed with stdout set to the write end of a pipe whose read end is held by the parent. The read end is set in non-blocking, signal-driven mode; its file descriptor, along with the packet, the server program name, and the child process' PID, is added to a list accessible to the SIGIO handler (which works through <a class="el" href="classLibWheel_1_1SignalQueue.html" title="A system for synchronously handling asynchronous signals in a uni-threaded process.">LibWheel::SignalQueue</a>). This handler is responsible for creating the connection and accepting the packet.</p>
<p>If <code>restrict_servers</code> is set, the child program is executed under the UID and GID of the owner of the program. If the program is accessed through a symbolic link, the UID and GID of the link must match those of the target.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>A packet that initializes a TCP connection. If the TCP SYN flag is not set on <em>pkt</em>, a message is logged and it is accepted immediately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000005">Bug:</a></b></dt><dd>Checking program ownership and using <code>execve()</code> to launch it results in a TOCTOU race condition. The solution is to use <code>fexecve()</code>. However, Linux does not currently implement the <code>fexecve()</code> system call, and its emulation in glibc does not work on Linux kernels prior to 2.6.22-rc1 if the calling program has called <code>setuid()</code> or <code>seteuid()</code>. This <em>may</em> have been fixed in Linux 2.6.22-rc1. When a version of <code>fexecve()</code> that <em>does</em> work becomes available, undefine the macro <code>BROKEN_FEXECVE</code> in the makefile to use <code>fexecve()</code> instead of <code>execve()</code>. </dd></dl>
<dl class="user"><dt><b>Side Effects:</b></dt><dd>Writes messages to <a class="el" href="namespaceLibWheel.html#af4ca70f4f65b2948701218436516a679" title="Global logmsg object.">LibWheel::logmsg</a>. </dd></dl>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l01062">1062</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>References <a class="el" href="IPQ_8cpp_source.html#l01069">IPQ::IpqTcpPacket::getTcpHeader()</a>, <a class="el" href="nerd_8cpp_source.html#l00281">verbose</a>, <a class="el" href="Logmsg_8hpp_source.html#l00047">LibWheel::logmsg</a>, <a class="el" href="logmsg_8h_source.html#l00072">logmsg_err</a>, <a class="el" href="nerd_8cpp_source.html#l00279">sock</a>, <a class="el" href="IPQ_8cpp_source.html#l00177">IPQ::IpqSocket::sendResponse()</a>, <a class="el" href="IPQ_8hpp_source.html#l00090">IPQ::IpqSocket::ACCEPT</a>, <a class="el" href="util_8cpp_source.html#l00037">LibWheel::ipv4_to_string()</a>, <a class="el" href="IPQ_8cpp_source.html#l00783">IPQ::IpqIpPacket::getIpDest()</a>, <a class="el" href="IPQ_8cpp_source.html#l00992">IPQ::IpqTcpPacket::getTcpDest()</a>, <a class="el" href="nerd_8cpp_source.html#l01278">findServer()</a>, <a class="el" href="Signals_8cpp_source.html#l00501">LibWheel::uninterruptible_close()</a>, <a class="el" href="nerd_8cpp_source.html#l00282">pendingConnections</a>, <a class="el" href="WaitList__impl_8cpp_source.html#l00115">LibWheel::WaitList::add()</a>, <a class="el" href="nerd_8cpp_source.html#l00226">NERD::ConnectionServer::ServerRecord::serverProgram</a>, <a class="el" href="logmsg_8h_source.html#l00075">logmsg_info</a>, <a class="el" href="nerd_8h_source.html#l00027">NERD_PIPE_FD</a>, <a class="el" href="nerd_8cpp_source.html#l00288">restrict_servers</a>, <a class="el" href="util_8cpp_source.html#l00093">LibWheel::close_files_on_exec()</a>, <a class="el" href="drop__priv_8c_source.html#l00091">drop_priv()</a>, <a class="el" href="nerd_8cpp_source.html#l00223">NERD::ConnectionServer::ServerRecord::serverAddr</a>, <a class="el" href="nerd_8cpp_source.html#l00224">NERD::ConnectionServer::ServerRecord::serverPort</a>, <a class="el" href="nerd_8cpp_source.html#l00227">NERD::ConnectionServer::ServerRecord::serverDnsRecord</a>, and <a class="el" href="logmsg_8h_source.html#l00073">logmsg_warning</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00894">handlePacket()</a>.</p>

</div>
</div>
<a class="anchor" id="ae713c47afe1f248809de764dfda4f1b2"></a><!-- doxytag: member="NERD::ConnectionServer::createConnection" ref="ae713c47afe1f248809de764dfda4f1b2" args="(IPQ::IpqUdpPacket *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NERD::ConnectionServer::createConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIPQ_1_1IpqUdpPacket.html">IPQ::IpqUdpPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a UDP connection. </p>
<p>This is not currently implemented, so a warning is logged and the packet is accepted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>A packet that initializes a UDP connection. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l01238">1238</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>References <a class="el" href="nerd_8cpp_source.html#l00281">verbose</a>, <a class="el" href="Logmsg_8hpp_source.html#l00047">LibWheel::logmsg</a>, <a class="el" href="logmsg_8h_source.html#l00073">logmsg_warning</a>, <a class="el" href="nerd_8cpp_source.html#l00279">sock</a>, <a class="el" href="IPQ_8cpp_source.html#l00177">IPQ::IpqSocket::sendResponse()</a>, and <a class="el" href="IPQ_8hpp_source.html#l00090">IPQ::IpqSocket::ACCEPT</a>.</p>

</div>
</div>
<a class="anchor" id="a9d75b0d048d374095c4d7c96e4add7f8"></a><!-- doxytag: member="NERD::ConnectionServer::findServer" ref="a9d75b0d048d374095c4d7c96e4add7f8" args="(ServerRecord &amp;rec, in_addr_t addr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NERD::ConnectionServer::findServer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNERD_1_1ConnectionServer_1_1ServerRecord.html">ServerRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in_addr_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const  throw (<a class="el" href="classNERD_1_1ConnectionServer_1_1UnknownServerException.html">UnknownServerException</a>)<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to find a server program to run in response to a connection request. </p>
<p>The following attempts are made:</p>
<ol type="1">
<li>search for a program named <em>rec.serverAddr:rec.serverPort</em> in <code>serverRoot</code> (example: 10.1.1.1:23)</li>
<li>search for a program named <em>rec.serverAddr</em> in <code>serverRoot</code> (example: 10.1.1.1)</li>
<li>perform a DNS query for a TXT record for <em>serverAddr</em> to get a semicolon-separated list of key=value pairs, and search for a program whose name is given by the value associated with the key P&lt;rec.serverPort&gt; in <code>serverRoot</code> (example: D=foobar.com;P25=smtpserver;P80=webserver). If more than one DNS TXT record is found, only the first one is used and a warning is logged.</li>
</ol>
<p>If no server program is found using any of these methods, an <a class="el" href="classNERD_1_1ConnectionServer_1_1UnknownServerException.html" title="Exception thrown by findServer() when no server program can be found to handle a new connection...">UnknownServerException</a> is thrown. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>A description of the connection requested. The following fields must be set when this function is called:<ul>
<li><a class="el" href="structNERD_1_1ConnectionServer_1_1ServerRecord.html#a741796c62f55fc2d3b7ac5807d4bfdf8" title="The IP address to be emulated by a server program, as a string.">ServerRecord::serverAddr</a></li>
<li><a class="el" href="structNERD_1_1ConnectionServer_1_1ServerRecord.html#a8eeda51ef462eeabb3d66b130fe70e56" title="The port number to be emulated by a server program, as a string.">ServerRecord::serverPort</a></li>
<li><a class="el" href="structNERD_1_1ConnectionServer_1_1ServerRecord.html#a8e253a76e9dbd9eaf239f09ff9d1e69f" title="The transport protocol of serverPort.">ServerRecord::serverProto</a></li>
</ul>
When this function returns, the <a class="el" href="structNERD_1_1ConnectionServer_1_1ServerRecord.html#a9bacaaa47cedda53feb069fbc1be8b8c" title="The name of a server program.">ServerRecord::serverProgram</a> filled will be filled with the name of the program to run, and the <a class="el" href="structNERD_1_1ConnectionServer_1_1ServerRecord.html#a1272b0f4ca611ecc8c2b2b76c75c5f91" title="The DNS TXT record for serverAddr.">ServerRecord::serverDnsRecord</a> field may be filled with the DNS TXT record for the server's IP address. </td></tr>
    <tr><td class="paramname">addr</td><td>The IP address of the requested server, in host byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classNERD_1_1ConnectionServer_1_1UnknownServerException.html" title="Exception thrown by findServer() when no server program can be found to handle a new connection...">UnknownServerException</a></td><td>If no server program can be found for the requested server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Side Effects:</b></dt><dd>May write messages to <a class="el" href="namespaceLibWheel.html#af4ca70f4f65b2948701218436516a679" title="Global logmsg object.">LibWheel::logmsg</a>. </dd></dl>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l01278">1278</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>References <a class="el" href="nerd_8cpp_source.html#l00280">serverRoot</a>, <a class="el" href="nerd_8cpp_source.html#l01347">isExecutable()</a>, <a class="el" href="dns_8cpp_source.html#l00059">LibWheel::getDnsTxt()</a>, <a class="el" href="Logmsg_8hpp_source.html#l00047">LibWheel::logmsg</a>, <a class="el" href="logmsg_8h_source.html#l00073">logmsg_warning</a>, <a class="el" href="util_8cpp_source.html#l00037">LibWheel::ipv4_to_string()</a>, <a class="el" href="nerd_8cpp_source.html#l00281">verbose</a>, <a class="el" href="logmsg_8h_source.html#l00075">logmsg_info</a>, <a class="el" href="DnsServerRecord_8cpp_source.html#l00084">NERD::DnsServerRecord::getValue()</a>, <a class="el" href="DnsServerRecord_8cpp_source.html#l00109">NERD::DnsServerRecord::end()</a>, and <a class="el" href="logmsg_8h_source.html#l00072">logmsg_err</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l01062">createConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="afd85b7ad69696355650a0177d01f0a06"></a><!-- doxytag: member="NERD::ConnectionServer::getRedirectRule" ref="afd85b7ad69696355650a0177d01f0a06" args="(const IPQ::IpqTcpPacket *pkt) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structNERD_1_1ConnectionServer_1_1AddressPair.html">ConnectionServer::AddressPair</a> &amp; NERD::ConnectionServer::getRedirectRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIPQ_1_1IpqTcpPacket.html">IPQ::IpqTcpPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td> const  throw (<a class="el" href="classNERD_1_1ConnectionServer_1_1UnknownConnectionException.html">UnknownConnectionException</a>)<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Looks up a redirection rule for a TCP packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The packet to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The redirection rule for <em>pkt</em>, if it exists. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classNERD_1_1ConnectionServer_1_1UnknownConnectionException.html" title="Exception thrown by getRedirectRule() when a packet does not match any existing connection record...">UnknownConnectionException</a></td><td>If no redirection rule for <em>pkt</em> exists. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l01002">1002</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>References <a class="el" href="nerd_8cpp_source.html#l00283">redirections</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00894">handlePacket()</a>.</p>

</div>
</div>
<a class="anchor" id="aca2ea51c7622b3ecb11cbaa976b9a137"></a><!-- doxytag: member="NERD::ConnectionServer::getRedirectRule" ref="aca2ea51c7622b3ecb11cbaa976b9a137" args="(const IPQ::IpqUdpPacket *pkt) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structNERD_1_1ConnectionServer_1_1AddressPair.html">ConnectionServer::AddressPair</a> &amp; NERD::ConnectionServer::getRedirectRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIPQ_1_1IpqUdpPacket.html">IPQ::IpqUdpPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td> const  throw (<a class="el" href="classNERD_1_1ConnectionServer_1_1UnknownConnectionException.html">UnknownConnectionException</a>)<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Looks up a redirection rule for a UDP packet. </p>
<p>UDP connection are not currently implemented, so this method simply throws an <a class="el" href="classNERD_1_1ConnectionServer_1_1UnknownConnectionException.html" title="Exception thrown by getRedirectRule() when a packet does not match any existing connection record...">UnknownConnectionException</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Theoretically, the redirection rule for the packet, but this is not currently implemented. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classNERD_1_1ConnectionServer_1_1UnknownConnectionException.html" title="Exception thrown by getRedirectRule() when a packet does not match any existing connection record...">UnknownConnectionException</a></td><td>If no redirection rule for the packet exists. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l01023">1023</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b183a39539b07fe4a92ef3ad88d7c92"></a><!-- doxytag: member="NERD::ConnectionServer::handlePacket" ref="a5b183a39539b07fe4a92ef3ad88d7c92" args="(IPQ::IpqPacket *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NERD::ConnectionServer::handlePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIPQ_1_1IpqPacket.html">IPQ::IpqPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle a packet. </p>
<p>If the packet is part of a pre-existing connection, redirect the packet accordingly. Otherwise, attempt to create a connection for the packet.</p>
<p>Currently, IP fragments and non-TCP/IP packets are not supported. Packets of these types will be accepted unmodified, and messages will be logged to <a class="el" href="namespaceLibWheel.html#af4ca70f4f65b2948701218436516a679" title="Global logmsg object.">LibWheel::logmsg</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>The packet to redirect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000004">Bug:</a></b></dt><dd>There is a bug in netfilter that causes locally-generated outbound packets with non-local source IP addresses to be dropped. Since packets returning to a client program from a server match this description after being redirected, they must be accepted with NF_STOP rather than NF_ACCEPT. This means that they do not continue iptables traversal, and cannot be filtered elsewhere in iptables. </dd></dl>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00894">894</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>References <a class="el" href="IPQ_8cpp_source.html#l00829">IPQ::IpqIpPacket::getMoreFrags()</a>, <a class="el" href="IPQ_8cpp_source.html#l00817">IPQ::IpqIpPacket::getFragOffset()</a>, <a class="el" href="Logmsg_8hpp_source.html#l00047">LibWheel::logmsg</a>, <a class="el" href="logmsg_8h_source.html#l00073">logmsg_warning</a>, <a class="el" href="nerd_8cpp_source.html#l00279">sock</a>, <a class="el" href="IPQ_8cpp_source.html#l00177">IPQ::IpqSocket::sendResponse()</a>, <a class="el" href="IPQ_8hpp_source.html#l00090">IPQ::IpqSocket::ACCEPT</a>, <a class="el" href="nerd_8cpp_source.html#l01002">getRedirectRule()</a>, <a class="el" href="logmsg_8h_source.html#l00075">logmsg_info</a>, <a class="el" href="util_8cpp_source.html#l00037">LibWheel::ipv4_to_string()</a>, <a class="el" href="IPQ_8cpp_source.html#l00772">IPQ::IpqIpPacket::getIpSource()</a>, <a class="el" href="IPQ_8cpp_source.html#l00981">IPQ::IpqTcpPacket::getTcpSource()</a>, <a class="el" href="IPQ_8cpp_source.html#l00783">IPQ::IpqIpPacket::getIpDest()</a>, <a class="el" href="IPQ_8cpp_source.html#l00992">IPQ::IpqTcpPacket::getTcpDest()</a>, <a class="el" href="IPQ_8cpp_source.html#l00840">IPQ::IpqIpPacket::getIpHeader()</a>, <a class="el" href="IPQ_8cpp_source.html#l01069">IPQ::IpqTcpPacket::getTcpHeader()</a>, <a class="el" href="nerd_8cpp_source.html#l00048">LOCALHOST_IP</a>, <a class="el" href="IPQ_8hpp_source.html#l00092">IPQ::IpqSocket::STOP</a>, <a class="el" href="nerd_8cpp_source.html#l01062">createConnection()</a>, <a class="el" href="IPQ_8cpp_source.html#l01226">IPQ::IpqUdpPacket::getUdpSource()</a>, <a class="el" href="IPQ_8cpp_source.html#l01237">IPQ::IpqUdpPacket::getUdpDest()</a>, <a class="el" href="IPQ_8cpp_source.html#l01248">IPQ::IpqUdpPacket::getUdpHeader()</a>, and <a class="el" href="IPQ_8cpp_source.html#l00794">IPQ::IpqIpPacket::getProtocol()</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00490">operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a31818d0fbe0366a7b902095445405406"></a><!-- doxytag: member="NERD::ConnectionServer::isExecutable" ref="a31818d0fbe0366a7b902095445405406" args="(const std::string &amp;file) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NERD::ConnectionServer::isExecutable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if a file is executable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file to check for executability. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if <em>file</em> exists and is executable by the current user; <b>false</b> otherwise. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If <em>file</em> cannot be accessed or exists but is not executable, a message is logged to <a class="el" href="namespaceLibWheel.html#af4ca70f4f65b2948701218436516a679" title="Global logmsg object.">LibWheel::logmsg</a>. </dd></dl>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l01347">1347</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>References <a class="el" href="Logmsg_8hpp_source.html#l00047">LibWheel::logmsg</a>, and <a class="el" href="logmsg_8h_source.html#l00072">logmsg_err</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l01278">findServer()</a>.</p>

</div>
</div>
<a class="anchor" id="af506b23a0c81f40f8f449bb388005424"></a><!-- doxytag: member="NERD::ConnectionServer::operator()" ref="af506b23a0c81f40f8f449bb388005424" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NERD::ConnectionServer::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main loop for <a class="el" href="classNERD_1_1ConnectionServer.html" title="The main class for the Network Rerouter Daemon (nerd).">ConnectionServer</a>. </p>
<p>Receive packets from libipq and pass them off to <a class="el" href="classNERD_1_1ConnectionServer.html#a5b183a39539b07fe4a92ef3ad88d7c92" title="Handle a packet.">ConnectionServer::handlePacket</a> for processing; stop when SIGINT is received. All signals that arrive through SignalQueue are also processed from this method. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00490">490</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>References <a class="el" href="nerd_8cpp_source.html#l00279">sock</a>, <a class="el" href="IPQ_8cpp_source.html#l00362">IPQ::IpqSocket::waitForPacket()</a>, <a class="el" href="Signals_8cpp_source.html#l00334">LibWheel::SignalQueue::getReadFD()</a>, <a class="el" href="Signals_8cpp_source.html#l00263">LibWheel::SignalQueue::handleNext()</a>, <a class="el" href="IPQ_8cpp_source.html#l00277">IPQ::IpqSocket::recvPacket()</a>, <a class="el" href="nerd_8cpp_source.html#l00894">handlePacket()</a>, <a class="el" href="Logmsg_8hpp_source.html#l00047">LibWheel::logmsg</a>, <a class="el" href="logmsg_8h_source.html#l00072">logmsg_err</a>, and <a class="el" href="logmsg_8h_source.html#l00074">logmsg_notice</a>.</p>

</div>
</div>
<a class="anchor" id="a52574c2792a324c56435234da19cc183"></a><!-- doxytag: member="NERD::ConnectionServer::printStats" ref="a52574c2792a324c56435234da19cc183" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NERD::ConnectionServer::printStats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print current server status to <a class="el" href="namespaceLibWheel.html#af4ca70f4f65b2948701218436516a679" title="Global logmsg object.">LibWheel::logmsg</a>. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00528">528</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>References <a class="el" href="Logmsg_8hpp_source.html#l00047">LibWheel::logmsg</a>, <a class="el" href="logmsg_8h_source.html#l00075">logmsg_info</a>, <a class="el" href="nerd_8cpp_source.html#l00283">redirections</a>, <a class="el" href="nerd_8cpp_source.html#l00284">timeoutList</a>, <a class="el" href="WaitList__impl_8cpp_source.html#l00140">LibWheel::WaitList::size()</a>, <a class="el" href="nerd_8cpp_source.html#l00282">pendingConnections</a>, <a class="el" href="nerd_8cpp_source.html#l00285">servers</a>, <a class="el" href="util_8cpp_source.html#l00064">LibWheel::open_files()</a>, <a class="el" href="nerd_8cpp_source.html#l00279">sock</a>, <a class="el" href="IPQ_8cpp_source.html#l00421">IPQ::IpqSocket::getPacketsReceived()</a>, <a class="el" href="IPQ_8cpp_source.html#l00432">IPQ::IpqSocket::getPacketsAccepted()</a>, and <a class="el" href="IPQ_8cpp_source.html#l00443">IPQ::IpqSocket::getPacketsDropped()</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l01387">NERD::StatPrinter::operator()()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a87fc9625f6d518ffe294e4f759d3cae0"></a><!-- doxytag: member="NERD::ConnectionServer::exitHandler" ref="a87fc9625f6d518ffe294e4f759d3cae0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNERD_1_1ConnectionServer_1_1ServerExitHandler.html">ServerExitHandler</a> <a class="el" href="classNERD_1_1ConnectionServer.html#a87fc9625f6d518ffe294e4f759d3cae0">NERD::ConnectionServer::exitHandler</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The functor that handles SIGCHLD signals when servers exit. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00286">286</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00463">~ConnectionServer()</a>.</p>

</div>
</div>
<a class="anchor" id="a3168fab5ca817d2cd2cb7ca15228440d"></a><!-- doxytag: member="NERD::ConnectionServer::magic_sock" ref="a3168fab5ca817d2cd2cb7ca15228440d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classNERD_1_1ConnectionServer.html#a3168fab5ca817d2cd2cb7ca15228440d">NERD::ConnectionServer::magic_sock</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A socket bound to 127.0.0.1:MAGIC_PORT/TCP. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00289">289</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00463">~ConnectionServer()</a>.</p>

</div>
</div>
<a class="anchor" id="ad051d0ac714b53904e86c368cd90275c"></a><!-- doxytag: member="NERD::ConnectionServer::pendingConnections" ref="ad051d0ac714b53904e86c368cd90275c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNERD_1_1ConnectionServer.html#ac838d247f33cef856ae722343a8cb7ff">PendingConnectionList</a> <a class="el" href="classNERD_1_1ConnectionServer.html#ad051d0ac714b53904e86c368cd90275c">NERD::ConnectionServer::pendingConnections</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The list of servers (and associated initial packets) which have been started but have not yet responded with packet numbers. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00282">282</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00528">printStats()</a>, <a class="el" href="nerd_8cpp_source.html#l00719">NERD::ConnectionServer::ServerExitHandler::operator()()</a>, <a class="el" href="nerd_8cpp_source.html#l00791">NERD::ConnectionServer::ServerExitHandler::findPendingConnection()</a>, <a class="el" href="nerd_8cpp_source.html#l00825">NERD::ConnectionServer::ServerWritebackHandler::operator()()</a>, and <a class="el" href="nerd_8cpp_source.html#l01062">createConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="a4186be4b373165c72ab81a73165cb075"></a><!-- doxytag: member="NERD::ConnectionServer::redirections" ref="a4186be4b373165c72ab81a73165cb075" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNERD_1_1ConnectionServer.html#a1f7b6abdda0f0a7a027a5f2e24727cee">RedirectionTable</a> <a class="el" href="classNERD_1_1ConnectionServer.html#a4186be4b373165c72ab81a73165cb075">NERD::ConnectionServer::redirections</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A hash table of rules governing packet redirections for open conncetions. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00283">283</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00528">printStats()</a>, <a class="el" href="nerd_8cpp_source.html#l00719">NERD::ConnectionServer::ServerExitHandler::operator()()</a>, <a class="el" href="nerd_8cpp_source.html#l00825">NERD::ConnectionServer::ServerWritebackHandler::operator()()</a>, and <a class="el" href="nerd_8cpp_source.html#l01002">getRedirectRule()</a>.</p>

</div>
</div>
<a class="anchor" id="ae54611cb80881c2a73d69e145df4bbd7"></a><!-- doxytag: member="NERD::ConnectionServer::restrict_servers" ref="ae54611cb80881c2a73d69e145df4bbd7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNERD_1_1ConnectionServer.html#ae54611cb80881c2a73d69e145df4bbd7">NERD::ConnectionServer::restrict_servers</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>true</b> to limit the privileges of server programs; <b>false</b> otherwise. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00288">288</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l01062">createConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e476e6dd3a15d073b4a3f75569dc240"></a><!-- doxytag: member="NERD::ConnectionServer::serverRoot" ref="a5e476e6dd3a15d073b4a3f75569dc240" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classNERD_1_1ConnectionServer.html#a5e476e6dd3a15d073b4a3f75569dc240">NERD::ConnectionServer::serverRoot</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The directory in which to search for server programs. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00280">280</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l01278">findServer()</a>.</p>

</div>
</div>
<a class="anchor" id="a990a4882c5123f35208d36cabb5fef67"></a><!-- doxytag: member="NERD::ConnectionServer::servers" ref="a990a4882c5123f35208d36cabb5fef67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNERD_1_1ConnectionServer.html#a0cd661f2a6755c501ac198229675ad4d">ServerTable</a> <a class="el" href="classNERD_1_1ConnectionServer.html#a990a4882c5123f35208d36cabb5fef67">NERD::ConnectionServer::servers</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A hash table of server process IDs and the connections that they handle. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00285">285</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00528">printStats()</a>, <a class="el" href="nerd_8cpp_source.html#l00719">NERD::ConnectionServer::ServerExitHandler::operator()()</a>, and <a class="el" href="nerd_8cpp_source.html#l00825">NERD::ConnectionServer::ServerWritebackHandler::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9575a11fd2db34b92ab1627c2d1d5b0"></a><!-- doxytag: member="NERD::ConnectionServer::sock" ref="ad9575a11fd2db34b92ab1627c2d1d5b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIPQ_1_1IpqSocket.html">IPQ::IpqSocket</a>&amp; <a class="el" href="classNERD_1_1ConnectionServer.html#ad9575a11fd2db34b92ab1627c2d1d5b0">NERD::ConnectionServer::sock</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A handle to libipq. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00279">279</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00463">~ConnectionServer()</a>, <a class="el" href="nerd_8cpp_source.html#l00490">operator()()</a>, <a class="el" href="nerd_8cpp_source.html#l00528">printStats()</a>, <a class="el" href="nerd_8cpp_source.html#l00825">NERD::ConnectionServer::ServerWritebackHandler::operator()()</a>, <a class="el" href="nerd_8cpp_source.html#l00894">handlePacket()</a>, and <a class="el" href="nerd_8cpp_source.html#l01062">createConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="adc22ef94ff5d014433eef07e054e1d69"></a><!-- doxytag: member="NERD::ConnectionServer::timeoutList" ref="adc22ef94ff5d014433eef07e054e1d69" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNERD_1_1ConnectionServer.html#a63d211040487b4566f2f696026723932">TimeoutList</a> <a class="el" href="classNERD_1_1ConnectionServer.html#adc22ef94ff5d014433eef07e054e1d69">NERD::ConnectionServer::timeoutList</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of redirection rules to be deleted when timeouts expire. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00284">284</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00528">printStats()</a>, and <a class="el" href="nerd_8cpp_source.html#l00719">NERD::ConnectionServer::ServerExitHandler::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a36f12900d6c2461984a1e093bfc42403"></a><!-- doxytag: member="NERD::ConnectionServer::verbose" ref="a36f12900d6c2461984a1e093bfc42403" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNERD_1_1ConnectionServer.html#a36f12900d6c2461984a1e093bfc42403">NERD::ConnectionServer::verbose</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>true</b> to log extra messages; <b>false</b> otherwise </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00281">281</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00719">NERD::ConnectionServer::ServerExitHandler::operator()()</a>, <a class="el" href="nerd_8cpp_source.html#l01062">createConnection()</a>, and <a class="el" href="nerd_8cpp_source.html#l01278">findServer()</a>.</p>

</div>
</div>
<a class="anchor" id="a8aa938754f8f34144d205d4dd208d91a"></a><!-- doxytag: member="NERD::ConnectionServer::writebackHandler" ref="a8aa938754f8f34144d205d4dd208d91a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNERD_1_1ConnectionServer_1_1ServerWritebackHandler.html">ServerWritebackHandler</a> <a class="el" href="classNERD_1_1ConnectionServer.html#a8aa938754f8f34144d205d4dd208d91a">NERD::ConnectionServer::writebackHandler</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The functor that handles SIGIO signals when servers write back their port numbers. </p>

<p>Definition at line <a class="el" href="nerd_8cpp_source.html#l00287">287</a> of file <a class="el" href="nerd_8cpp_source.html">nerd.cpp</a>.</p>

<p>Referenced by <a class="el" href="nerd_8cpp_source.html#l00463">~ConnectionServer()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="nerd_8cpp_source.html">nerd.cpp</a></li>
</ul>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 28 2012 13:00:09 for Network Rerouter Daemon (nerd) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5
</small></address>

</body>
</html>
