<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Network Rerouter Daemon (nerd): Bug List</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Network Rerouter Daemon (nerd)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Bug List </div>  </div>
</div>
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_bug000001"></a>Class <a class="el" href="classIPQ_1_1IpqSocket.html">IPQ::IpqSocket</a>  </dt>
<dd><p class="startdd">Connect() does not detect if other another program is using libipq. Instead, if another program is connected, recvPacket() will throw an exception. This is due to a limitation in libipq. </p>
<p class="enddd">Due to a bug in Netfilter, changing the source IP address of a packet to a non-local address and then setting a verdict of NF_ACCEPT will cause it to be dropped. This has been observed when the packet was queued from the OUTPUT chain of the mangle table. A work-around is to set a verdict of NF_STOP instead of NF_ACCEPT, but be aware that this results in the packet being treated differently by iptables. Kernels prior to 2.6.12 do not have NF_STOP; defining NO_NF_STOP enables another work-around: all packets are immediately dropped, and packets that are to be accepted are re-injected through raw sockets. In this case, care must be taken to ensure that infinite queueing loops do not occur. Also, this work-around only works for IP packets.  </p>
</dd>
<dt><a class="anchor" id="_bug000006"></a>Class <a class="el" href="classLibWheel_1_1WaitList.html">LibWheel::WaitList</a>  </dt>
<dd>The timer interrupt handler (WaitList::WaitGC) assumes that the list is sorted in chronological order. However, since list iterators are provided, this is not necessarily true. Consequently, objects that are out of chronological order will not be removed until after all objects before them in list order have timed out and been removed. </dd>
<dt><a class="anchor" id="_bug000002"></a>Class <a class="el" href="classNERD_1_1ConnectionServer.html">NERD::ConnectionServer</a>  </dt>
<dd>As described above, servers that have not responded within 10 seconds are assumed to be malfunctioning and are dropped. However, if the server is in fact still running, it will exit when it receives the SIGINT or at some later time. This will result in a warning message indicating that SIGCHLD was received from a process for which no record exists. This could probably be fixed, but an extra log message is not currently considered to be a problem worthy of the effort required to fix it.  </dd>
<dt><a class="anchor" id="_bug000003"></a>Member <a class="el" href="classNERD_1_1ConnectionServer_1_1AddressPairHash.html#a36bbb841fe3f2cbacb4cab2687675c4d">NERD::ConnectionServer::AddressPairHash::operator()</a>  (const AddressPair &amp;addr) const </dt>
<dd>I haven't done any analysis of it, but this hash function probably isn't very good.  </dd>
<dt><a class="anchor" id="_bug000005"></a>Member <a class="el" href="classNERD_1_1ConnectionServer.html#af4ba681fed213914c83661a1dfd8df6d">NERD::ConnectionServer::createConnection</a>  (<a class="el" href="classIPQ_1_1IpqTcpPacket.html" title="An complete IPv4/TCP packet that was received via IpqSocket.">IPQ::IpqTcpPacket</a> *pkt)</dt>
<dd>Checking program ownership and using <code>execve()</code> to launch it results in a TOCTOU race condition. The solution is to use <code>fexecve()</code>. However, Linux does not currently implement the <code>fexecve()</code> system call, and its emulation in glibc does not work on Linux kernels prior to 2.6.22-rc1 if the calling program has called <code>setuid()</code> or <code>seteuid()</code>. This <em>may</em> have been fixed in Linux 2.6.22-rc1. When a version of <code>fexecve()</code> that <em>does</em> work becomes available, undefine the macro <code>BROKEN_FEXECVE</code> in the makefile to use <code>fexecve()</code> instead of <code>execve()</code>.  </dd>
<dt><a class="anchor" id="_bug000004"></a>Member <a class="el" href="classNERD_1_1ConnectionServer.html#a5b183a39539b07fe4a92ef3ad88d7c92">NERD::ConnectionServer::handlePacket</a>  (<a class="el" href="classIPQ_1_1IpqPacket.html" title="Base class for packets received via IpqSocket.">IPQ::IpqPacket</a> *pkt)</dt>
<dd>There is a bug in netfilter that causes locally-generated outbound packets with non-local source IP addresses to be dropped. Since packets returning to a client program from a server match this description after being redirected, they must be accepted with NF_STOP rather than NF_ACCEPT. This means that they do not continue iptables traversal, and cannot be filtered elsewhere in iptables. </dd>
</dl>
</div></div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 28 2012 13:00:07 for Network Rerouter Daemon (nerd) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5
</small></address>

</body>
</html>
